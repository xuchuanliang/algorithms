# 算法
> 背包是一种不支持从中删除元素的集合数据类型--他的目的就是帮助用例收集元素并迭代遍历所有收集到的元素；
队列是一种基于先进先出FIFO策略的集合类型
栈是一种基于先进后出策略的集合类型
2019年7月15日 12:15:53 165/651 排序
2019年7月16日 18:14:22 172/651 选择排序和插入排序
2019年7月23日 14:01:20 183/651 归并排序








# 算法图解
# 第一章 算法简介
## 1.2 二分查找
> 二分查找是一种算法，其输入是一个有序的元素列表（必须有序的原因稍后解释）。如果要查找的元素包含在列表中，二分查找返回其位置；否则返回null。  
>对于包含n个元素的列表，用二分查找最多需要log2n步，而简单查找最多需要n步。  
>仅当列表是有序的时候，二分查找才管用  

## 快速排序
- 快速排序基本思想：选中一个基准点，将数组分成基准点左边是比基准点小，右边是比基准点大的两个数组，采用递归的思想，直到数组长度为1或空的数组表示不用排序

## 散列表
- 散列表必须满足以下要求：
1.它必须是一致的。例如，假设你输入apple时得到的是4，那么每次输入apple时，得到的都必须为4。如果不是这样，散列表将毫无用处。
2.它应将不同的输入映射到不同的数字。 例如， 如果一个散列函数不管输入是什么都返回1，它就不是好的散列函数。最理想的情况是，将不同的输入映射到不同的数字。
- 散列表的特点：
1.散列函数总是将同样的输入映射到相同的索引。
2.散列函数将不同的输入映射到不同的索引。 
3.散列函数知道数组有多大，只返回有效的索引。
- 散列表是使用散列函数和数组组成的一种数据结构
- 散列表的应用场景：1.创建映射；2.查找
- 散列表冲突：当key被hash算法映射成为一个相同的key时，就在该位置存储一个链表
>散列表的经验教训有两个：
>>1.散列函数很重要。前面的散列函数将所有的键都映射到一个位置，而最理想的情况是， 散列函数将键均匀地映射到散列表的不同位置。
>>2.如果散列表存储的链表很长，散列表的速度将急剧下降。然而， 如果使用的散列函数很好，这些链表就不会很长！
>散列表要避免冲突，主要注意两个方面：1.较低的填装因子；2.良好的散列函数
- 填装因子=散列表包含的元素数/位置总数，例如，数组长度是10，元素一共有5个，则填装因子是0.5，如果元素一共是20个，则填装因子是2
>因为散列表使用数组来存储数据，填装因子是计算数组中被占用的位置数
- 填装因子越低，发生冲突的可能性越小，散列表的性能越高。一般情况下，一个填装因子大于0.7，就调整散列表的长度。
1.你可以结合散列函数和数组来创建散列表。
2.冲突很糟糕，你应使用可以最大限度减少冲突的散列函数。
3.散列表的查找、插入和删除速度都非常快。
4.散列表适合用于模拟映射关系。
5.一旦填装因子超过0.7，就该调整散列表的长度。
6.散列表可用于缓存数据（例如，在Web服务器上）。
7.散列表非常适合用于防止重复。


