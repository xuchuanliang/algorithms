# 算法
## 二分查找
>二分查找说明：给定有序的整数数组int[] arr以及需要查询的整数x，在arr中查找x的索引，若未查询到的返回-1
>说明：因为数组是有序的，所以每次都从中间位置开始查找，如果中间的值大于x，则从中间的左侧继续二分查找，若中间的
>值小于x，则从中间的值右侧开始二分查找，若中间的值等于x，则返回该索引；循环结束条件就是要么找到了x的位置，要么左侧索引不小于右侧索引

## 优先队列
### 堆得定义
&emsp;&emsp;数据结构二叉堆能够很好地实现优先队列的基本操作。在二叉堆的数组中，每个元素都要保证大于等于另两个特定位置的元素。相应地，
这些位置的元素又至少要大于等于数组中的另两个元素，以此类推。如果我们将所有元素画成一棵二叉树，将每个较大元素和两个较小的元素
用边连接就可以很容易看出这种结构。
### 堆有序
当一棵二叉树的每个结点都大于等于它的两个子结点时，它被称为堆有序。
###二叉堆表示法
&emsp;&emsp;如果我们用指针来表示堆有序的二叉树，那么每个元素都需要三个指针来找到它的上下结点（父结点和两个子
结点各需要一个）。如果我们使用完全二叉树，表达就会变得特别方便。要画出这样一棵完全
二叉树，可以先定下根结点，然后一层一层地由上向下、从左至右，在每个结点的下方连接两个更小的结点，直至
将 N 个结点全部连接完毕。完全二叉树只用数组而不需要指针就可以表示。具体方法就是将二叉树的结点按照层级顺序放入数组中，
根结点在位置 1，它的子结点在位置 2 和 3，而子结点的子结点则分别在位置 4、 5、 6 和 7，以此类推。<br>
&emsp;&emsp;在一个堆中，位置 k 的结点的父结点的位置为k/2，而它的两个子结点的位置则分别为 2k 和 2k+1。这样在不使用指针的情况下（我们在第 3 章
中讨论二叉树时会用到它们）我们也可以通过计算数组的索引在树中上下移动：从 a[k] 向上一层
就令 k 等于 k/2，向下一层则令 k 等于 2k 或 2k+1
###二叉堆的定义
二叉堆是一组能够用堆有序的完全二叉树排序的元素，并在数组中按照层级储存（不使用数组的第一个位置）。

>**简单起见，下文中我们将二叉堆简称为堆**










# 算法图解
# 第一章 算法简介
## 1.2 二分查找
> 二分查找是一种算法，其输入是一个有序的元素列表（必须有序的原因稍后解释）。如果要查找的元素包含在列表中，二分查找返回其位置；否则返回null。  
>对于包含n个元素的列表，用二分查找最多需要log2n步，而简单查找最多需要n步。  
>仅当列表是有序的时候，二分查找才管用  

## 快速排序
- 快速排序基本思想：选中一个基准点，将数组分成基准点左边是比基准点小，右边是比基准点大的两个数组，采用递归的思想，直到数组长度为1或空的数组表示不用排序

## 散列表
- 散列表必须满足以下要求：
1.它必须是一致的。例如，假设你输入apple时得到的是4，那么每次输入apple时，得到的都必须为4。如果不是这样，散列表将毫无用处。
2.它应将不同的输入映射到不同的数字。 例如， 如果一个散列函数不管输入是什么都返回1，它就不是好的散列函数。最理想的情况是，将不同的输入映射到不同的数字。
- 散列表的特点：
1.散列函数总是将同样的输入映射到相同的索引。
2.散列函数将不同的输入映射到不同的索引。 
3.散列函数知道数组有多大，只返回有效的索引。
- 散列表是使用散列函数和数组组成的一种数据结构
- 散列表的应用场景：1.创建映射；2.查找
- 散列表冲突：当key被hash算法映射成为一个相同的key时，就在该位置存储一个链表
>散列表的经验教训有两个：
>>1.散列函数很重要。前面的散列函数将所有的键都映射到一个位置，而最理想的情况是， 散列函数将键均匀地映射到散列表的不同位置。
>>2.如果散列表存储的链表很长，散列表的速度将急剧下降。然而， 如果使用的散列函数很好，这些链表就不会很长！
>散列表要避免冲突，主要注意两个方面：1.较低的填装因子；2.良好的散列函数
- 填装因子=散列表包含的元素数/位置总数，例如，数组长度是10，元素一共有5个，则填装因子是0.5，如果元素一共是20个，则填装因子是2
>因为散列表使用数组来存储数据，填装因子是计算数组中被占用的位置数
- 填装因子越低，发生冲突的可能性越小，散列表的性能越高。一般情况下，一个填装因子大于0.7，就调整散列表的长度。
1.你可以结合散列函数和数组来创建散列表。
2.冲突很糟糕，你应使用可以最大限度减少冲突的散列函数。
3.散列表的查找、插入和删除速度都非常快。
4.散列表适合用于模拟映射关系。
5.一旦填装因子超过0.7，就该调整散列表的长度。
6.散列表可用于缓存数据（例如，在Web服务器上）。
7.散列表非常适合用于防止重复。

# 广度优先搜索
- 解决最短路径问题的算法被称为广度优先搜索（BFS）。 广度优先搜索让你能够找出两样东西之间的最短距离。
## 图是什么
- 图模拟一组连接。图由节点（ node） 和边（ edge） 组成。图由节点和边组成。一个节点可能与众多节点直接相连，这些节点被称为邻居。图用于模拟不同的东西是如何相连的。
- 广度优先搜索是一种用于图的查找算法，可帮助回答两类问题。1.第一类问题：从节点A出发，有前往节点B的路径吗？2.第二类问题：从节点A出发，前往节点B的哪条路径最短？
- 在广度优先搜索的执行过程中，搜索范围从起点开始逐渐向外延伸，即先检查一度关系，再检查二度关系。
- 队列只支持两种操作： 入队和出队
- 队列是一种先进先出（ First In First Out， FIFO）的数据结构，而栈是一种后进先出（ Last In First Out， LIFO）的数据结构。
- 有向图（ directed graph） ，其中的关系是单向的。
- 无向图（ undirected graph） 没有箭头，直接相连的节点互为邻居。
- 广度优先算法实际上是将图划分成度，即距离初始节点如果直接关联则是1度，如果是第二个节点就是2度，然后通过队列先进先出的方式，
每搜索一个节点时就将该节点的关联节点推到队列的后面，这样就会先搜索1度的所有节点，其次搜索2度的节点知道最终将所有节点搜索完，也是递归的思想。
>图总结：
>>1.广度优先搜索指出是否有从A到B的路径。
>>2.如果有，广度优先搜索将找出最短路径。
>>3.面临类似于寻找最短路径的问题时，可尝试使用图来建立模型，再使用广度优先搜索来解决问题。
>>4.有向图中的边为箭头，箭头的方向指定了关系的方向，例如， rama→adit表示rama欠adit钱。
>>5.无向图中的边不带箭头，其中的关系是双向的，例如， ross - rachel表示“ross与rachel约会，而rachel也与ross约会”。
>>6.队列是先进先出（ FIFO）的。
>>7.栈是后进先出（ LIFO）的。
>>8.你需要按加入顺序检查搜索列表中的人，否则找到的就不是最短路径，因此搜索列表必须是队列。
>>9.对于检查过的人，务必不要再去检查，否则可能导致无限循环。

# 狄克斯特拉算法
>狄克斯特拉算法包含4个步骤：
>1.找出“最便宜”的节点，即可在最短时间内到达的节点。
>2.更新该节点的邻居的开销，其含义将稍后介绍。
>3.重复这个过程，直到对图中的每个节点都这样做了。
>4.计算最终路径。
- 狄克斯特拉算法用于每条边都有关联数字的图，这些数字称为权重（ weight）。带权重的图称为加权图（ weighted graph），不带权重的图称为非加权图（ unweighted graph）。
- 要计算非加权图中的最短路径，可使用广度优先搜索。要计算加权图中的最短路径，可使用狄克斯特拉算法。

# 贪婪算法
- 每一步都采取最优解，即每一步都选举局部最优解，最终得到的就是全局最优解。


